name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      SERVER_PATH: /var/www/cyberr-middleware
    steps:
      - uses: actions/checkout@v4

      - name: Install SSH Key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.PRODUCTION_ENV_SSH_PRIVATE_KEY }}
          known_hosts: 'placeholder'
          if_key_exists: replace

      - name: Add bastion to known_hosts
        run: ssh-keyscan -p ${{ secrets.BASTION_SSH_PORT }} -H ${{ secrets.BASTION_HOST }} >> ~/.ssh/known_hosts

      - name: Add target to known_hosts via bastion
        run: ssh -p ${{ secrets.BASTION_SSH_PORT }} ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} ssh-keyscan -H ${{ secrets.PRODUCTION_ENV_HOST }} >> ~/.ssh/known_hosts

      - name: Sync repository to server path
        run: |
          rsync -avz --delete \
            -e "ssh -J ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}:${{ secrets.BASTION_SSH_PORT }}" \
            --exclude 'node_modules' \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '.env' \
            ./ ${{ secrets.SERVER_USERNAME }}@${{ secrets.PRODUCTION_ENV_HOST }}:${{ env.SERVER_PATH }}/

      - name: Create .env and deploy with docker compose
        run: |
          ssh -J ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}:${{ secrets.BASTION_SSH_PORT }} \
            ${{ secrets.SERVER_USERNAME }}@${{ secrets.PRODUCTION_ENV_HOST }} "bash -s" << 'ENDSSH'
          set -euo pipefail
          cd "${{ env.SERVER_PATH }}"

          # Create/overwrite .env for docker compose variable substitution
          cat > .env << 'EOL'
          # Required
          UPSTREAM_BEARER=${{ secrets.UPSTREAM_BEARER }}

          # Optional
          UPSTREAM_URL=${{ secrets.UPSTREAM_URL }}
          REQUIRE_API_KEY=${{ secrets.REQUIRE_API_KEY }}
          MIDDLEWARE_API_KEY=${{ secrets.MIDDLEWARE_API_KEY }}
          API_KEY_HEADER=${{ secrets.API_KEY_HEADER }}
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
          CACHE_TTL_SECONDS=${{ secrets.CACHE_TTL_SECONDS }}
          UPSTREAM_TIMEOUT_MS=30000
          RATE_LIMIT_PER_MINUTE=${{ secrets.RATE_LIMIT_PER_MINUTE }}
          LOG_LEVEL=${{ secrets.LOG_LEVEL }}
          TRUST_PROXY=${{ secrets.TRUST_PROXY }}
          HTTPS_PROXY=${{ secrets.PROXY }}
          HTTP_PROXY=${{ secrets.PROXY }}
          NO_PROXY=localhost,127.0.0.1,app.cyberr.ai
          EOL
          chmod 600 .env || true

          # Network/build settings: avoid bake/buildx
          export DOCKER_BUILDKIT=0
          export COMPOSE_DOCKER_CLI_BUILD=0

          # Configure proxy for Docker build
          export HTTP_PROXY="${{ secrets.PROXY }}"
          export HTTPS_PROXY="${{ secrets.PROXY }}"
          export NO_PROXY="localhost,127.0.0.1"

          # Build and (re)start
          # Pre-pull base image to avoid on-build fetches
          docker pull node:20-alpine || true
          docker compose pull || true
          echo "=== Building with --no-cache and proxy, capturing full output ==="
          docker compose build --no-cache --progress=plain \
            --build-arg HTTP_PROXY="$HTTP_PROXY" \
            --build-arg HTTPS_PROXY="$HTTPS_PROXY" \
            --build-arg NO_PROXY="$NO_PROXY" \
            2>&1 | tee /tmp/build.log
          echo "=== Starting services ==="
          docker compose up -d

          # Basic health check
          ok=0
          for i in $(seq 1 20); do
            if curl -fsS http://127.0.0.1:8002/healthz >/dev/null 2>&1; then
              ok=1
              break
            fi
            sleep 3
          done
          if [ "$ok" != "1" ]; then
            echo "Health check failed. Showing diagnostics..." >&2
            docker compose ps || true
            docker compose logs --no-color --tail=200 job-middleware || true
            exit 1
          fi
          ENDSSH
